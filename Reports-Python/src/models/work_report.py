from utils.validator import validate_required, validate_type, validate_instance_of
from models.work_package import WorkPackage
from models.refinement_context import RefinementContext
from models.availability_spec import AvailabilitySpec
from models.work_digest import WorkDigest
import json
from typing import Optional, List

class WorkReport:
    """
    Represents a Work-Report (R) generated by a guarantor.
    This is the primary output of the off-chain refinement process.
    """

    def __init__(
        self,
        work_package: WorkPackage,
        refinement_context: RefinementContext,
        pvm_output: str,
        gas_used: int,
        availability_spec: Optional[AvailabilitySpec],
        guarantor_signature: str,
        guarantor_public_key: str,
        core_index: int,
        slot: int,
        dependencies: Optional[List[str]] = None
    ):
        validate_instance_of(work_package, 'Work Package', WorkPackage)
        validate_instance_of(refinement_context, 'Refinement Context', RefinementContext)
        validate_required(pvm_output, 'PVM Output')
        validate_type(pvm_output, 'PVM Output', str)
        validate_required(gas_used, 'Gas Used')
        validate_type(gas_used, 'Gas Used', int)
        if gas_used < 0:
            raise ValueError('Gas Used cannot be negative.')

        if availability_spec is not None:
            validate_instance_of(availability_spec, 'Availability Specification', AvailabilitySpec)
            validate_type(guarantor_signature, 'Guarantor Signature', str)
            validate_required(guarantor_public_key, 'Guarantor Public Key')

        validate_required(core_index, 'Core Index')
        validate_type(core_index, 'Core Index', int)
        if core_index < 0:
            raise ValueError('Core Index cannot be negative.')

        validate_required(slot, 'Slot')
        validate_type(slot, 'Slot', int)
        if slot < 0:
            raise ValueError('Slot cannot be negative.')

        if dependencies is None:
            dependencies = []
        if not isinstance(dependencies, list) or not all(isinstance(d, str) for d in dependencies):
            raise ValueError('Dependencies must be a list of strings.')

        self.work_package = work_package
        self.refinement_context = refinement_context
        self.pvm_output = pvm_output
        self.gas_used = gas_used
        self.availability_spec = availability_spec
        self.guarantor_signature = guarantor_signature
        self.guarantor_public_key = guarantor_public_key
        self.core_index = core_index
        self.slot = slot
        self.dependencies = dependencies

    def to_signable_object(self) -> dict:
        """
        Converts the WorkReport to a plain dict for serialization (excluding signature for hashing).
        """
        return {
            'workPackage': self.work_package.to_object(),
            'refinementContext': self.refinement_context.to_object(),
            'pvmOutput': self.pvm_output,
            'gasUsed': self.gas_used,
            'availabilitySpec': self.availability_spec.to_object() if self.availability_spec else None,
            'coreIndex': self.core_index,
            'slot': self.slot,
            'dependencies': self.dependencies,
        }

    def to_object(self) -> dict:
        """
        Converts the WorkReport to a plain dict for full serialization (including signature).
        """
        obj = self.to_signable_object()
        obj['guarantorSignature'] = self.guarantor_signature
        obj['guarantorPublicKey'] = self.guarantor_public_key
        return obj

    def generate_digest(self) -> WorkDigest:
        """
        Generate a WorkDigest by hashing the signable portion of the report.
        This matches how digests are tracked in on-chain state and dispute logs.
        """
        payload = json.dumps(self.to_signable_object(), separators=(",", ":"), sort_keys=True)
        digest_hex = WorkDigest.sha256_hash(payload)
        return WorkDigest(digest_hex)